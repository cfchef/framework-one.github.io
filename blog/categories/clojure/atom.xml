<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Clojure | FW/1 - The Invisible Framework]]></title>
  <link href="http://framework-one.github.io/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://framework-one.github.io/"/>
  <updated>2015-09-17T19:27:12-07:00</updated>
  <id>http://framework-one.github.io/</id>
  <author>
    <name><![CDATA[Sean Corfield]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[FW/1 3.5.0 Beta 1 Available!]]></title>
    <link href="http://framework-one.github.io/blog/2015/09/10/fw1-3-5-0-beta-1/"/>
    <updated>2015-09-10T13:35:00-07:00</updated>
    <id>http://framework-one.github.io/blog/2015/09/10/fw1-3-5-0-beta-1</id>
    <content type="html"><![CDATA[<p>The <a href="https://github.com/framework-one/fw1/releases/tag/v3.5.0-beta1">first Beta release of FW/1 3.5.0</a> is available for testing.</p>

<p>The focus of this release is integration:<!--more--></p>

<ul>
  <li>Support for controllers and services to be written in CFML (<code>.cfc</code>), Clojure (<code>.clj</code>), or Lucee (<code>.lucee</code>)</li>
  <li>Support for views and layouts to be written in CFML (<code>.cfm</code>) or Lucee (<code>.lucee</code>)</li>
  <li>Configurable folder names to set your own conventions (for <em>controllers</em>, <em>layouts</em>, <em>subsystems</em>, and <em>views</em>)</li>
  <li>Support for <code>Application.cfc</code> to use FW/1 without extending <code>framework.one</code></li>
  <li>A new, cleaner, more consistent set of conventions for adding subsystems to an existing application</li>
</ul>

<p>You can read the <a href="https://github.com/framework-one/fw1/issues?q=is%3Aissue+milestone%3A3.5+is%3Aclosed">full list of changes since 3.0</a> on GitHub.</p>

<p>The <a href="/documentation/3.5/">documentation for 3.5</a> has been completely overhauled with complete descriptions of all the new features, as well as many
clarifications and expansions of existing features. In particular, you’ll want to check out:</p>

<ul>
  <li><a href="/documentation/3.5/developing-applications.html#alternative-application-structure">Alternative Application Structure</a></li>
  <li><a href="/documentation/3.5/using-subsystems.html#subsystems-10-vs-20">Subsystems 1.0 vs 2.0</a></li>
  <li><a href="/documentation/3.5/cfml-and-clojure.html">Using Clojure with CFML</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FW/1 New Releases Etc]]></title>
    <link href="http://framework-one.github.io/blog/2015/09/06/fw1-news/"/>
    <updated>2015-09-06T22:25:00-07:00</updated>
    <id>http://framework-one.github.io/blog/2015/09/06/fw1-news</id>
    <content type="html"><![CDATA[<p>A couple of months have passed since <a href="http://framework-one.github.io/blog/2015/07/12/fw1-3-1-released/">FW/1 3.1 was released</a> but things have been busy behind the scenes!</p>

<p>As indicated in July, work on FW/1 3.5 had been progressing in parallel (the first time two releases of FW/1 have been worked on concurrently!) and you can already download <a href="https://github.com/framework-one/fw1/releases/tag/v3.5.0-alpha2">FW/1 3.5 Alpha 2</a>.
Yes, there was an <a href="https://github.com/framework-one/fw1/releases/tag/v3.5.0-alpha1">Alpha 1</a> as well, but as work progressed on the <a href="http://framework-one.github.io/documentation/3.5/">massively overhauled 3.5 documentation</a>, some important usability enhancements
appeared and a new alpha was released within 24 hours! In particular, the <a href="http://framework-one.github.io/documentation/3.5/cfml-and-clojure.html">Clojure and CFML Sitting in a Tree</a> section has been extensively updated and includes a fully worked example of
how to create FW/1 application from scratch using the REPL to create Clojure services and controllers, with CFML views and layouts!</p>

<p>You’ll also probably notice that the FW/1 website has had a facelift, finally getting the look’n’feel that Kevin Stannard designed five years ago. Better late than never, and huge thanks to Kevin again for his wonderful logo design and choice of colors!
The 3.5 documentation now includes a table of contents on each page, making it easier to navigate (this will probably get backported to 3.1 and 3.0 at some point).</p>

<p>In addition to the ongoing work on FW/1 3.5, we also have an <a href="https://github.com/framework-one/fw1/releases/tag/v3.1.1">important bug fix release for the 3.1.x version</a> which addresses a potential problem with REST APIs.</p>

<p>Finally, if you’re a <a href="https://www.ortussolutions.com/products/commandbox">CommandBox</a> fan, we have good news: you can now easily install FW/1 3.1.2 and 3.5.0 (prerelease) via <code>box</code>. I’ll be blogging about this shortly. The 3.1.2 release is exactly the same as 3.1.1 (including the version number!)
but it includes <code>box.json</code> for compatibility with ForgeBox / CommandBox. In addition, Tony Junkes has contributed an <a href="https://github.com/framework-one/fw1-commands">initial set of <code>box</code> commands for FW/1</a> that let you get up and running quickly. This will be covered in the next blog post.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lucee and FW/1]]></title>
    <link href="http://framework-one.github.io/blog/2015/01/29/lucee-fw1/"/>
    <updated>2015-01-29T13:30:49-08:00</updated>
    <id>http://framework-one.github.io/blog/2015/01/29/lucee-fw1</id>
    <content type="html"><![CDATA[<p>Today saw the announcement of the <a href="http://lucee.org">Lucee Association Switzerland</a> and the release of a new open source CFML engine: <a href="http://lucee.org/downloads.html">Lucee 4.5.0</a>.</p>

<p>For background on the new engine and the association behind it, read <a href="http://blog.adamcameron.me/2015/01/lucee.html">Adam Cameron’s blog post with Q&amp;A</a> about the launch.</p>

<p>I’ve already migrated all my local test environments to Lucee and can report that FW/1 (and DI/1 and cfmljure) all run beautifully on it - and it will be my primary test environment for future development of the FW/1 family going forward.</p>

<p>I’ve also migrated my local dev environment for World Singles over to Lucee and that went pretty smoothly too (I encountered just two issues - both minor, one already fixed in Lucee’s master repository).</p>

<p>The <a href="https://bitbucket.org/lucee/lucee/wiki/Home">Lucee wiki</a> has information about downloading and installing Lucee, as well as building Lucee from source, and how to migrate from Railo to Lucee (hint: it’s really easy - stop the server, remove <code>railo.jar</code>, add <code>lucee.jar</code>, start the server).</p>

<p>Have fun with Lucee!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FW/1 & Clojure Sitting in Tree]]></title>
    <link href="http://framework-one.github.io/blog/2015/01/25/fw1-clojure-sitting-in-a-tree/"/>
    <updated>2015-01-25T13:30:49-08:00</updated>
    <id>http://framework-one.github.io/blog/2015/01/25/fw1-clojure-sitting-in-a-tree</id>
    <content type="html"><![CDATA[<p>Anyone following my tech trajectory will know that, after starting to learn Clojure in 2010, I’ve moved increasingly away from CFML and toward Clojure. In 2014, my team decided that Clojure would be our official primary language and all new development would happen there instead of in CFML. We still have a lot of CFML code in production - about 90kloc - but we consider it “legacy code” at this point. Most of that CFML code is a large ColdBox app that we built about five years ago (technically it’s three ColdBox apps but they share a lot of code). Our application Model has been slowly moving to Clojure so that we can reuse that code in new applications we’re building in Clojure. We’ve also been building new apps with FW/1 (and reusing both our CFML code and our Clojure code). We still like CFML as a templating language for views and our controllers - in our FW/1 apps at least - are often mostly just “glue” code that lets us call into our Clojure model code.<!-- more --></p>

<p>I’ve talked in passing on the FW/1 mailing list about the possibility of deeper integration with Clojure and I recently published <a href="https://github.com/framework-one/cfmljure/releases/tag/v0.1.0">cfmljure 0.1.0</a> - which I’ll be blogging about shortly - and so the topic came up again on the mailing list about this integration. I’d been thinking about how to write controllers in Clojure so that you could have a FW/1 app that used CFML for the views - where it excels as a templating language - and Clojure for the controllers and the model, leveraging the expressive power and immutable safety for all your business logic.</p>

<p>Over the last few days, I created a fork of FW/1 3.0 that included cfmljure and built a proof of concept of Clojure controllers. You can take a look at the <a href="https://github.com/framework-one/fw1/tree/clojure/examples/6helloclojure">FW/1 example with Clojure controllers</a> on the <code>clojure</code> branch of the FW/1 repo. I created the project using Leiningen (Clojure’s build tool) and then added <code>Application.cfc</code>, <code>index.cfm</code>, and the <code>views/</code> tree. Then I wrote the <code>controllers/main.clj</code> file (in <code>src/hello</code>) and the <code>controllers_test.clj</code> test file (in <code>test/hello</code>). Unit testing is built in, so you can run <code>lein test</code> to see the results. Then I refactored the Clojure code (creating the separate <code>greet.clj</code> file) and added a “service” in Clojure just for fun. The FW/1 app uses <code>framework.ioclj</code> - a extended version of DI/1 that uses cfmljure - to auto-discover the Clojure code (and the CFML code - you can mix’n’match) and wraps the Clojure controllers in <code>framework.cljcontroller</code> (to adapt to Clojure’s pure function calling convention, and to handle some FW/1-specific functionality). The CFML views are run as usual (and if you look in <code>views/main/default.cfm</code> you’ll see a call to the Clojure “service” via the bean factory: <code>getBeanFactory().getBean("greeterService").greetings("Earthling!")</code>).</p>

<p>I’m rather excited about this because it means we’ll have a way, at work, to further migrate our model code from CFML to Clojure, while maintaining “legacy” CFML code alongside, <em>right there in the same FW/1 application!</em></p>

<p>This won’t be part of FW/1 3.0. Instead it will stay on the <code>clojure</code> branch until release 3.0 is out (<code>develop</code> will be merged to <code>master</code> for that), but it will be part of FW/1 3.5 which will be the next release. That way it can get some field testing in production as well as some polish and some documentation love. Stay tuned!</p>

<p>p.s. Right now cfmljure only runs on Railo. The CFML code itself could be made portable enough to run on ColdFusion but the real problem is interop with Java/Clojure: ColdFusion thinks 42 is a string and so you need to do a lot of string-to-number conversions to interact with Clojure through cfmljure. I haven’t used ColdFusion for over five years - just Railo - so I don’t have much incentive, but if you feel inclined to send a Pull Request with changes to make cfmljure ColdFusion-compatible…</p>

<p>p.p.s. cfmljure now runs on Adobe ColdFusion 11, Lucee, and Railo! Thanks to Andrew Myers for tackling ColdFusion support.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cfmljure Release 0.1.0]]></title>
    <link href="http://framework-one.github.io/blog/2015/01/23/cfmljure-0-1-0/"/>
    <updated>2015-01-23T13:30:49-08:00</updated>
    <id>http://framework-one.github.io/blog/2015/01/23/cfmljure-0-1-0</id>
    <content type="html"><![CDATA[<p>I started cfmljure back in 2010, a few months after I started to learn Clojure, as a way to run Clojure code inside a CFML application. That early version worked - we’ve been using it in at World Singles since mid-2011 to integrate Clojure into our large ColdBox application, and updated versions of cfmljure have been in very heavy production usage since May 2012.<!-- more --> Those early versions were pretty clunky to setup though, since you needed to mess with the classpath of your CFML engine (or at least the container on which you ran it - Tomcat, in our case) and you needed to copy all your third-party library dependencies into the <code>WEB-INF/lib</code> folder (and restart your container if you changed your dependencies).</p>

<p>When Clojure 1.6 came out (March 2014), it introduced a new API for embedding Clojure inside other JVM applications. I’d been relying on an unsupported API so I wanted to move to the new API as soon as possible. I ran into problems with classpath handling so I put it on the back burner for a while. One of the things that bothered me about the earlier cfmljure was that you had to do so much configuration and manual copying of libraries. Leiningen handles all this for you in Clojure and I wanted things to be that slick for cfmljure. I experimented with some CFML code that executed Leiningen to retrieve the classpath and I had some success, but not enough to create a reliable version that could be used in our app at work.</p>

<p>This past week, I decided to have another run at it, using a different approach to manipulating the classpath in my running CFML application:</p>

<pre><code>// extend the classloader - not at all sketchy, honest!
var threadProxy = createObject( "java", "java.lang.Thread" );
var appCL = threadProxy.currentThread().getContextClassLoader();
var urlCLProxy = createObject( "java", "java.net.URLClassLoader" );
var addURL = urlCLProxy.getClass().getDeclaredMethod( "addURL", __classes( "URL", 1, "java.net" ) );
addUrl.setAccessible( true ); // hack to make it callable
for ( var newURL in urls.toArray() ) {
    addURL.invoke( appCL, [ newURL ] );
}
</code></pre>

<p>I gleaned the principle of this from time spent on Google and StackOverflow and several snippets of Java code that did this same thing. It uses Java Reflection to get a handle on <code>URLClassLoader.addURL()</code> and change its access to public so that it can be called by code that doesn’t extend the <code>URLClassLoader</code> class. This got me past the previous blocking point and I was able to complete the rewrite of that earlier version of cfmljure to use the new Clojure 1.6 API and also leverage Leiningen to avoid that configuration and manual copying.</p>

<p>I present: <a href="https://github.com/framework-one/cfmljure/releases/tag/v0.1.0">cfmljure Release 0.1.0</a>! An easy-to-use way to embed a Clojure project into your CFML application (running on Lucee or Railo).</p>

<p>The documentation is in the <a href="https://github.com/framework-one/cfmljure/blob/master/README.md">cfmljure README</a> on Github but the basic flow is as follows:</p>

<ul>
  <li>Create a Clojure project with Leiningen: <code>lein new myproject</code></li>
  <li>Create an instance of cfmljure pointing at that project folder: <code>var clj = new cfmljure("/path/to/myproject");</code></li>
  <li>Install Clojure namespaces into a struct (or a scope): <code>clj.install("clojure.core,myproject.core",this);</code></li>
  <li>Call Clojure code: <code>this.clojure.core.println("Hello World!");</code></li>
</ul>

<p>That’s about as simple as it gets!</p>
]]></content>
  </entry>
  
</feed>
